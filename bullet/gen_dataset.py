"""Generates a dataset from the following files:

States:
    <args.states_dir>/
        <sid>.p = {
            "objects": {
                <oid>: {
                    "shape": <shape>,
                    "color": <color>,
                    "radius": <radius>,
                    "height": <height>,
                    "position": <position>,
                    "orientation": <orientation
                }
            }
            "robot": {<joint_name>: <joint_angle>}
        }

Images:
    <args.images_dir>/
        rgb/
            <sid>.png
        masks/
            <sid>.npy
# Note that IDs in the mask must correspond to the IDs in object states.

<args.dataset_dir>/
    eids.json
    json/
        <sid>.json
"""
import argparse
import imageio
import numpy as np
import os

from ns_vqa_dart.bullet.dash_dataset import DashDataset
import ns_vqa_dart.bullet.dash_object as dash_object
import ns_vqa_dart.bullet.random_objects as random_objects
import ns_vqa_dart.bullet.util as util


def main(args: argparse.Namespace):
    data_dir = os.path.join(args.dataset_dir, "data")
    os.makedirs(data_dir, exist_ok=True)

    paths = []
    for sid in range(100):
        state = util.load_pickle(
            path=os.path.join(args.states_dir, f"{sid:06}.p")
        )

        # TODO: Do states processing in an earlier stage, including:
        #   1. Generate and map object IDs to object dictionaries.
        #   2. Generate and assign colors (necessary for image creation).
        #   3. Filter out objects that have mask area of zero (according to
        #       the bullet mask, requiring the Unity camera to match exactly).
        oid2odict = {}
        for idx in range(len(state["objects"])):
            odict = state["objects"][idx]
            odict["color"] = random_objects.generate_random_color()
            oid = idx
            oid2odict[oid] = odict
        state["objects"] = oid2odict

        # rgb and masks generated by Unity
        # mask = np.load(f"~/datasets/dash_v001/masks/{sid:06}.npy")
        rgb_square = load_rgb(dataset_dir=args.dataset_dir, sid=sid)
        # Crop rgb image from (480, 480, 4) to (320, 480, 3)
        rgb = np.zeros((320, 480, 3), dtype=np.uint8)
        rgb = rgb_square[80:400, :, :3]
        mask = np.full((320, 480), 15, dtype=np.uint8)

        # Randomly set patches of object segments (for now).
        for oid in state["objects"].keys():
            start_idx = oid * 150 + 100  # 0, 25, 50, 75
            end_idx = start_idx + 100  # 20, 45, 50, 75
            mask[start_idx:end_idx, start_idx:end_idx] = oid

        # Save the input data.
        for oid, odict in state["objects"].items():
            print(f"oid: {oid}")
            print(f"rgb: ({rgb.min()}, {rgb.max()})")
            print(f"mask: ({mask.min()}, {mask.max()})")
            X = dash_object.compute_X(oid=oid, rgb=rgb, mask=mask)
            y = dash_object.compute_y(odict=odict, coordinate_frame="world")
            path = save_example(data_dir=data_dir, sid=sid, oid=oid, X=X, y=y)
            paths.append(path)

    # Save a partition of the data.
    split_id = int(len(paths) * 0.8)
    partition = {
        "train": paths[:split_id],
        "val": paths[split_id:],
        "test": paths[split_id:],
    }
    util.save_json(
        path=os.path.join(args.dataset_dir, "partition.json"), data=partition
    )
    train = len(partition["train"])
    val = len(partition["val"])
    test = len(partition["test"])
    print(f"Saved partition. Train: {train}\tValidation: {val}\tTest: {test}")


def load_rgb(dataset_dir: str, sid: int):
    rgb_square = imageio.imread(
        os.path.join(dataset_dir, "rgb", f"{sid:06}.png")
    )
    return rgb_square


def save_example(
    data_dir: str, sid: int, oid: int, X: np.ndarray, y: np.ndarray
):
    eid = f"{sid:06}_{oid:02}"
    path = os.path.join(data_dir, f"{eid}.p")
    util.save_pickle(path=path, data=[X, y, sid, oid, path])
    return path


def sid_oid_to_pickle_path(dataset_dir: str, sid: int, oid: int):
    eid = f"{sid:06}_{oid:02}"
    path = os.path.join(dataset_dir, "data", f"{eid}.p")
    return path


def path_to_sid_oid(path: str):
    eid = os.path.splitext(os.path.basename(path))[0]
    sid, oid = eid.split("_")
    return int(sid), int(oid)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--dataset_dir",
        required=True,
        type=str,
        help="The directory to save the data in.",
    )
    parser.add_argument(
        "--states_dir",
        required=True,
        type=str,
        help="The directory to load states from.",
    )
    args = parser.parse_args()
    main(args)
